import { show } from '../../../utils/show.ts'
const _show = new show()
import * as ink from 'https://deno.land/x/ink/mod.ts'

export class websiteDirbrut {
    async init(url:string, wordlist:string[]) {
        _show.log(`Starting web exploit dir brutforcer with url ${url} and wordlist ${wordlist.length} words\n`)
        if(!url.endsWith('/')) {
            url = url + '/'
        }
        let baseURL = this.getAllBaseurl(wordlist)
        let executable = this.getAllExecutable(wordlist)
        let simpleURL = this.getAllSimpleURL(wordlist)
        for(let i = 0; i < baseURL.length; i++) {
            if(baseURL[i].url.startsWith('/')) {
                baseURL[i].url = baseURL[i].url.substring(1)
            }
        }
        for(let i = 0; i < executable.length; i++) {
            if(executable[i].startsWith('/')) {
                executable[i] = executable[i].substring(1)
            }
        }
        for(let i = 0; i < simpleURL.length; i++) {
            if(simpleURL[i].startsWith('/')) {
                simpleURL[i] = simpleURL[i].substring(1)
            }
        }
        wordlist = this.genetateWordlist(baseURL, executable, simpleURL)
        await this.main(url, wordlist)
    }

    async main(url:string, wordlist:string[]) {
        let l:string[] = []
        for(let i = 0; i < wordlist.length; i++) {
            if(await this.makeRequest(url + wordlist[i])) {
                l.push(url+wordlist[i])
            }
        }
        let repportName = Date.now() + '_dirbrut.txt'
        console.log()
        _show.log(`Found ${l.length} urls, ./db/dirbrut/${repportName}`)
        Deno.mkdirSync('./db/dirbrut', { recursive: true })
        Deno.writeTextFileSync(`./db/dirbrut/${repportName}`, l.join('\n'))
    }


    private async makeRequest(url:string) {
        try {
            let req = await fetch(url)
            if(req.status == 200 || req.status == 201) {
                _show.log(`${url} is ${ink.colorize("<green>online</green>")}`)
                return true
            } else {
                _show.log(`${url} status ${ink.colorize("<red>"+req.status+"</red>")}`)
            }
        } catch(err){
            _show.log(`${url} is invalid`)
        }
        return false
    }

    private getAllBaseurl(wordlist: string[]) {
        let b:any = []
        for(let i = 0; i < wordlist.length; i++) {
            if(wordlist[i].startsWith('base b')) {
                let data = wordlist[i].split(' ')
                if(!data[2].endsWith('/')) {
                    data[2] = data[2] + '/'
                }
                b.push({
                    id: data[1],
                    url: data[2]
                })
            }
        }
        return b
    }

    private getAllExecutable(wordlist:string[]){
        let e:any = []
        for(let i = 0; i < wordlist.length; i++) {
            if(wordlist[i].startsWith('exec ')) {
                let data = wordlist[i].split(' ')
                e.push(data[1])
            }
        }
        return e
    }

    private getAllSimpleURL(wordlist:string[]){
        let s:any = []
        for(let i = 0; i < wordlist.length; i++) {
            if(!wordlist[i].startsWith('base b') && !wordlist[i].startsWith('exec ')) {
                s.push(wordlist[i])
            }
        }
        return s
    }

    private genetateWordlist(base:any, executable:any, simple:any) {
        let url:string[] = []
        for(let i = 0; i < simple.length; i++) {
            if(simple != "" && simple != '/' && simple != null && simple != ' ') {
                url.push(simple[i])
            }
        }
        for(let i = 0; i < base.length; i++) {
            for(let j = 0; j < executable.length; j++) {
                url.push(base[i].url + executable[j])
            }
        }
        //filter the duplicates
        url = url.filter((v, i, a) => a.indexOf(v) === i)
        return url
    }
}